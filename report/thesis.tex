%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% EPFL report package, main thesis file
% Goal: provide formatting for theses and project reports
% Author: Mathias Payer <mathias.payer@epfl.ch>
%
% To avoid any implication, this template is released into the
% public domain / CC0, whatever is most convenient for the author
% using this template.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\documentclass[a4paper,11pt,oneside]{report}
% Options: MScThesis, BScThesis, MScProject, BScProject
\usepackage[BScThesis,lablogo]{EPFLreport}
\usepackage{xspace}

\title{Tooling and Analysis of the Scudo Allocator}
\author{Elias Valentin Boschung}
\supervisor{Mao Philipp Yuxiang}
\adviser{Prof. Dr. sc. ETH Mathias Payer}
%\coadviser{Second Adviser}
%\expert{The External Reviewer}

\newcommand{\sysname}{ScudoGEFPlugin\xspace}

\begin{document}
\maketitle{}
\makededication{}
\makeacks{}

\begin{abstract}
  The \sysname{} tool enables inspection of the heap memory of an android app
  which uses native C libraries.

  While there is a lot of existent tooling to debug errors related to heap
  memory in C code, it is only for the standard libc allocator. However
  Android uses its own allocator since Android 11, the scudo hardened
  allocator. Since scudo uses its own structures and way to allocate memory,
  those tools can not be used for debugging android C libraries.

  In this project the goal was to analyze the way scudo allocates memory and
  then write some tooling to debug it. The tool developed takes the form of
  an extras plugin into the popular GEF plugin for GDB, which in turn is a
  popular debugger for C programs.
  
The abstract serves as an executive summary of your project.
Your abstract should cover at least the following topics, 1-2 sentences for
each: what area you are in, the problem you focus on, why existing work is
insufficient, what the high-level intuition of your work is, maybe a neat
design or implementation decision, and key results of your evaluation.
\end{abstract}

\maketoc{}

%%%%%%%%%%%%%%%%%%%%%%
\chapter{Introduction}
%%%%%%%%%%%%%%%%%%%%%%

The introduction is a longer writeup that gently eases the reader into your
thesis~\cite{dinesh20oakland}. Use the first paragraph to discuss the setting.
In the second paragraph you can introduce the main challenge that you see.
The third paragraph lists why related work is insufficient.
The fourth and fifth paragraphs discuss your approach and why it is needed.
The sixth paragraph will introduce your thesis statement. Think how you can
distill the essence of your thesis into a single sentence.
The seventh paragraph will highlight some of your results
The eights paragraph discusses your core contribution.

This section is usually 3-5 pages.

%%%%%%%%%%%%%%%%%%%%
\chapter{Background}
%%%%%%%%%%%%%%%%%%%%

Most standard android apps are written in Java, which is the main development
language for writing android apps. However for more advanced uses there exists
support for including libraries written in standard C code, called native libraries
referring to the underlying structure of android which is actually a modified
version of linux. These native libraries can be used together with Java code,
allowing C functions to be called from the java part of the code.

In C, the memory is divided into three big types that are handled differently.
There is the data segment, which contains the global and static variables that
are defined in a program, and the data segment can be further divided into the
initialized global and static variables, and the uninitialized or initalized to
zero global and static variables.
Then there is the stack, which is used for local variables in a function as well
as for arguments and some additional info about called functions. The size of
variables on the stack have to be fixed-size and the variables lifetime is limited
to the scope of the function.
The third type of memory is the one important for this thesis, the heap memory.
The heap memory is the most flexible of the three types of memory, as it isn't
limited to a specific lifetime like the stack and variables on the heap can be
resized. Heap memory can be allocated by the programmer by calling the $malloc$
function, and unlike the stack or data segment, it has to be explicitly freed by
the programmer again, by calling $free$. To resize a variable on the heap, the
$realloc$ function can be used. Since the variables have to be freed manually,
the programmer has full control over the lifetime of a variable on the heap, and
it can be used for variables that are needed outside of the scope of a single
function. Furthermore the heap has a virtually infinite amount of space, and is
generally also used for very big memory allocations. However due to this big
flexibility, the handling of heap memory is also quite error-prone, by forgetting
to free allocated memory or allocating a chunk of the wrong size of the heap and
trying to access memory outside the allocated part.

Due to the ability to resize the heap variables and their flexible lifetime, the
heap can't simply allocate contiguous chunks of memory in the order that variables
were allocated, as there would have to be a lot of moving when variables were
resized and there would be a lot of space lost when some chunks in the middle of
the heap were freed. Instead, there is a lot of bookkeeping done around which
chunks of memory are allocated, which are free and the heap allocator tries to
decide in a smart way which chunks to allocate when and where to get as much
performance as possible.

While the general concepts of these memory types are universal for the C language,
there are some differences in the concrete implementation, especially of the heap
allocator. While most linux programs use the more standard libc malloc, which is
well documented and for which tooling exists to investigate the state of the heap,
android uses it's own allocator since Android 11, which is called the scudo
hardened allocator.



Explain how scudo allocates memory in the primary and secondary allocator.

The background section introduces the necessary background to understand your
work. This is not necessarily related work but technologies and dependencies
that must be resolved to understand your design and implementation.

This section is usually 3-5 pages.


%%%%%%%%%%%%%%%%
\chapter{Design}
%%%%%%%%%%%%%%%%

Explain gdb, gef and gef extra plugins and how they come together/interact.

Introduce and discuss the design decisions that you made during this project.
Highlight why individual decisions are important and/or necessary. Discuss
how the design fits together.

This section is usually 5-10 pages.


%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Implementation}
%%%%%%%%%%%%%%%%%%%%%%%%

Explain how the plugin is specifically structured, how the commands, the data
structures and the constants are defined.



The implementation covers some of the implementation details of your project.
This is not intended to be a low level description of every line of code that
you wrote but covers the implementation aspects of the projects.

This section is usually 3-5 pages.


%%%%%%%%%%%%%%%%%%%%
\chapter{Evaluation}
%%%%%%%%%%%%%%%%%%%%

Give some examples of the crashes analyzed, how the commands of the plugin
can be used to figure out what's happening.

In the evaluation you convince the reader that your design works as intended.
Describe the evaluation setup, the designed experiments, and how the
experiments showcase the individual points you want to prove.

This section is usually 5-10 pages.


%%%%%%%%%%%%%%%%%%%%%%
\chapter{Related Work}
%%%%%%%%%%%%%%%%%%%%%%

Mention some of the links as provided for the beginning of the project.

The related work section covers closely related work. Here you can highlight
the related work, how it solved the problem, and why it solved a different
problem. Do not play down the importance of related work, all of these
systems have been published and evaluated! Say what is different and how
you overcome some of the weaknesses of related work by discussing the 
trade-offs. Stay positive!

This section is usually 3-5 pages.


%%%%%%%%%%%%%%%%%%%%
\chapter{Conclusion}
%%%%%%%%%%%%%%%%%%%%

In the conclusion you repeat the main result and finalize the discussion of
your project. Mention the core results and why as well as how your system
advances the status quo.

\cleardoublepage{}
\phantomsection{}
\addcontentsline{toc}{chapter}{Bibliography}
\printbibliography{}

% Appendices are optional
% \appendix
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \chapter{How to make a transmogrifier}
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% In case you ever need an (optional) appendix.
%
% You need the following items:
% \begin{itemize}
% \item A box
% \item Crayons
% \item A self-aware 5-year old
% \end{itemize}

\end{document}
